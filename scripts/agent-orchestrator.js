#!/usr/bin/env node

/**
 * vCFO of One - Dynamic Agent Orchestrator
 * 
 * Template for creating orchestrators for other "Of One" sites.
 * Replace vCFO of One, Small business owners without a full-time CFO, and customize TASK_REGISTRY.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Site-specific configuration
const SITE_CONFIG = {
  name: 'vCFO of One',  // e.g., 'Director of One'
  domain: 'vcofone.ai',   // e.g., 'directorofone.ai'
  targetAudience: 'Small business owners without a full-time CFO', // e.g., 'one-person department managers'
  primaryColor: '#4169E1',  // Utlyze blue (keep consistent)
  accentColor: '#00A878',  // Customize per site type
};

// Task Registry with Dependencies
const TASK_REGISTRY = {
  // Design & Branding Tasks
  'design-system': {
    id: 'design-system',
    name: `Create ${SITE_CONFIG.name} Design System`,
    path: 'frontend/src/styles/design-system.ts',
    dependencies: [],
    estimatedHours: 3,
    priority: 'CRITICAL',
    prompt: `Create design system for ${SITE_CONFIG.name}. Use Utlyze blue (#4169E1) as primary, ${SITE_CONFIG.accentColor} as accent. Target audience: ${SITE_CONFIG.targetAudience}. Clean, professional, trustworthy design.`,
    completionCheck: () => fs.existsSync('frontend/src/styles/design-system.ts')
  },

  // Content Creation Tasks
  'content-strategy': {
    id: 'content-strategy',
    name: `Develop ${SITE_CONFIG.name} Content`,
    dependencies: [],
    estimatedHours: 4,
    priority: 'CRITICAL',
    prompt: `Create content for ${SITE_CONFIG.name}. Target: ${SITE_CONFIG.targetAudience}. Pain points: Making money or just managing money?, Hours in Excel with no clarity, Unpredictable cashflow, Unclear KPIs and metrics. Solution: AI-driven virtual CFO providing financial insight and oversight on demand. Focus on Real-time financial insights, Cash flow forecasting, Custom KPI tracking, ROI analysis on all initiatives.`,
    completionCheck: () => fs.existsSync('content/copy/homepage.md')
  },

  // Frontend Development Tasks
  'nextjs-setup': {
    id: 'nextjs-setup',
    name: 'Initialize Next.js Project',
    dependencies: [],
    estimatedHours: 2,
    priority: 'CRITICAL',
    prompt: 'Initialize Next.js 14 with TypeScript, Tailwind CSS, App Router. Standard Utlyze setup.',
    completionCheck: () => fs.existsSync('frontend/package.json')
  },

  'component-library': {
    id: 'component-library',
    name: 'Build Component Library',
    dependencies: ['nextjs-setup', 'design-system'],
    estimatedHours: 4,
    priority: 'HIGH',
    prompt: 'Create reusable components using design system. Standard Utlyze component set.',
    completionCheck: () => fs.existsSync('frontend/src/components/ui/Button.tsx')
  },

  'landing-page': {
    id: 'landing-page',
    name: `Build ${SITE_CONFIG.name} Landing Page`,
    dependencies: ['component-library', 'content-strategy'],
    estimatedHours: 4,
    priority: 'CRITICAL',
    prompt: `Build landing page for ${SITE_CONFIG.name}. Hero, pain points, solution, features, testimonials, CTAs. Multiple consultation CTAs.`,
    completionCheck: () => fs.existsSync('frontend/src/app/page.tsx')
  },

  // Backend Tasks
  'api-setup': {
    id: 'api-setup',
    name: 'Setup API Infrastructure',
    dependencies: [],
    estimatedHours: 3,
    priority: 'HIGH',
    prompt: 'Standard Express.js API setup with TypeScript. Vercel-ready.',
    completionCheck: () => fs.existsSync('backend/src/api/server.ts')
  },

  // Animation Tasks
  'animation-system': {
    id: 'animation-system',
    name: 'Create Animation System',
    dependencies: ['design-system'],
    estimatedHours: 3,
    priority: 'HIGH',
    prompt: `Create a comprehensive animation system for ${SITE_CONFIG.name}. Include: 1) Framer Motion setup and configuration, 2) Reusable animation variants (fade, slide, scale, etc.), 3) Custom hooks for animations (useScrollAnimation, useHoverAnimation), 4) Animation utilities and helpers. Use smooth, professional animations that enhance UX without being distracting. Consider accessibility with prefers-reduced-motion.`,
    completionCheck: () => fs.existsSync('frontend/src/utils/animations.ts')
  },

  'component-animations': {
    id: 'component-animations',
    name: 'Add Component Animations',
    dependencies: ['component-library', 'animation-system'],
    estimatedHours: 2,
    priority: 'MEDIUM',
    prompt: `Add animations to all UI components. Include: hover effects, click feedback, loading states, entrance animations. Keep animations subtle and professional for ${SITE_CONFIG.targetAudience}.`,
    completionCheck: () => fs.existsSync('frontend/src/components/ui/AnimatedButton.tsx')
  },

  'page-transitions': {
    id: 'page-transitions',
    name: 'Implement Page Transitions',
    dependencies: ['landing-page', 'animation-system'],
    estimatedHours: 2,
    priority: 'MEDIUM',
    prompt: `Implement smooth page transitions and scroll-triggered animations for the landing page. Include: hero section fade-in, feature cards stagger animation, testimonial carousel, CTA pulse effects, smooth scroll behavior. All animations should enhance the professional feel.`,
    completionCheck: () => fs.existsSync('frontend/src/components/PageTransition.tsx')
  },

  'micro-interactions': {
    id: 'micro-interactions',
    name: 'Add Micro-interactions',
    dependencies: ['component-animations'],
    estimatedHours: 1,
    priority: 'LOW',
    prompt: `Add subtle micro-interactions throughout the site: form field focus effects, button ripples, tooltip animations, success/error state transitions, loading spinners. Focus on details that make the site feel polished and responsive.`,
    completionCheck: () => fs.existsSync('frontend/src/components/ui/MicroInteractions.tsx')
  },

  // Add more tasks as needed...
};

// Standard orchestrator functions (same as CEO of One)
function findReadyTasks() {
  const readyTasks = [];
  const completedTasks = new Set();
  
  for (const [taskId, task] of Object.entries(TASK_REGISTRY)) {
    if (task.completionCheck && task.completionCheck()) {
      completedTasks.add(taskId);
    }
  }
  
  for (const [taskId, task] of Object.entries(TASK_REGISTRY)) {
    if (completedTasks.has(taskId)) continue;
    
    const dependenciesMet = task.dependencies.every(dep => completedTasks.has(dep));
    if (dependenciesMet) {
      readyTasks.push(task);
    }
  }
  
  const priorityOrder = { 'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3 };
  readyTasks.sort((a, b) => {
    return (priorityOrder[a.priority] || 3) - (priorityOrder[b.priority] || 3);
  });
  
  return { readyTasks, completedTasks };
}

function generateAgentCommands(tasks) {
  const commands = [];
  
  tasks.forEach((task, index) => {
    const command = {
      terminal: index + 1,
      name: task.name,
      command: `cd "${process.cwd()}" && CURSOR_BACKGROUND_AGENT_PROMPT="${task.prompt}" npm run background`,
      estimatedHours: task.estimatedHours,
      priority: task.priority
    };
    commands.push(command);
  });
  
  return commands;
}

function main() {
  console.log(`ðŸš€ ${SITE_CONFIG.name} - Dynamic Agent Orchestrator\n`);
  console.log('Analyzing project state...\n');
  
  const { readyTasks, completedTasks } = findReadyTasks();
  const totalTasks = Object.keys(TASK_REGISTRY).length;
  const blockedTasks = totalTasks - completedTasks.size - readyTasks.length;
  
  console.log(`ðŸ“Š Task Status:`);
  console.log(`   - Total tasks: ${totalTasks}`);
  console.log(`   - Completed: ${completedTasks.size}`);
  console.log(`   - Ready to start: ${readyTasks.length}`);
  console.log(`   - Blocked: ${blockedTasks}\n`);
  
  if (completedTasks.size > 0) {
    console.log('âœ… Completed Tasks:');
    for (const taskId of completedTasks) {
      console.log(`   - ${TASK_REGISTRY[taskId].name}`);
    }
    console.log('');
  }
  
  if (readyTasks.length === 0) {
    if (completedTasks.size === totalTasks) {
      console.log(`ðŸŽ‰ All tasks completed! ${SITE_CONFIG.name} is ready for launch.`);
    } else {
      console.log('â¸ï¸  No tasks are currently ready. Some tasks may be blocked by dependencies.');
    }
    return;
  }
  
  console.log(`ðŸ¤– Deploy ${readyTasks.length} Agents Right Now!\n`);
  
  const commands = generateAgentCommands(readyTasks);
  const totalHours = commands.reduce((sum, cmd) => sum + cmd.estimatedHours, 0);
  const maxHours = Math.max(...commands.map(c => c.estimatedHours));
  
  console.log(`â±ï¸  Estimated time: ${maxHours} hours (running in parallel)`);
  console.log(`ðŸ“ˆ Total work: ${totalHours} hours compressed into parallel execution\n`);
  
  console.log('â”€'.repeat(80));
  commands.forEach(cmd => {
    console.log(`\n### Agent ${cmd.terminal}: ${cmd.name}`);
    console.log(`Priority: ${cmd.priority} | Estimated: ${cmd.estimatedHours} hours`);
    console.log('```bash');
    console.log(cmd.command);
    console.log('```');
  });
  console.log('\n' + 'â”€'.repeat(80));
  
  console.log('\nðŸ“‹ Instructions:');
  console.log('1. Open ' + commands.length + ' terminal windows or Cursor background agents');
  console.log('2. Copy and run each command above');
  console.log('3. Agents will work autonomously in parallel');
  console.log('4. Run this orchestrator again to see newly available tasks');
  
  const stateFile = path.join(process.cwd(), '.agent-orchestrator-state.json');
  const state = {
    timestamp: new Date().toISOString(),
    projectName: SITE_CONFIG.name,
    completedTasks: Array.from(completedTasks),
    readyTasks: readyTasks.map(t => t.id),
    blockedTasks,
    totalTasks,
    estimatedCompletion: `${maxHours} hours`
  };
  
  fs.writeFileSync(stateFile, JSON.stringify(state, null, 2));
  console.log(`\nðŸ’¾ State saved to ${stateFile}`);
}

if (require.main === module) {
  main();
}

module.exports = { findReadyTasks, generateAgentCommands, TASK_REGISTRY, SITE_CONFIG };